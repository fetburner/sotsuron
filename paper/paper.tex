\documentclass{sumiilab-paper}
%% uplatex を使う場合：
% \documentclass[uplatex]{sumiilab-paper}
\usepackage{amsmath,amssymb,amsfonts,ascmac,cases,bm}
\usepackage{cite}
\usepackage{enumitem}
\usepackage{bussproofs}
\usepackage{url}

%% ===============================================
%% 論文の表紙に表示される情報
%% ===============================================

% 論文の年度と種類
\paper{平成 26 年度 卒業論文}% 学部生
%\paper{平成 n 年度 修士論文}% 修士

% 論文のタイトル
\title{MinCamlのK正規化の形式的検証}

% 学籍番号と著者のお名前
\author{B2TB2512 水野雅之}

% 著者の所属
\institute{東北大学 工学部\\情報知能システム総合学科}% 学部生
%\institute{東北大学 大学院情報科学研究科\\情報基礎科学専攻}% 修士

% 指導教員のお名前
\supervisor{住井 英二郎 教授}% 指導教員
\subsupervisor{松田 一孝 准教授}% 論文指導教員(省略可)

% 論文発表日時
\date{平成27年3月11日 \quad 13:30--14:00}
% 発表場所
\venue{電気通信研究所 本館5階ゼミ室(M531)}

%% ===============================================
%% ソースコードの設定
%% ===============================================

% プログラミング言語と表示するフォント等の設定
\lstset{
  language={[Objective]Caml},% プログラミング言語
  basicstyle={\ttfamily\small},% ソースコードのテキストのスタイル
  keywordstyle={\bfseries},% 予約語等のキーワードのスタイル
  commentstyle={},% コメントのスタイル
  stringstyle={},% 文字列のスタイル
  frame=trlb,% ソースコードの枠線の設定 (none だと非表示)
  numbers=left,% 行番号の表示 (none だと非表示)
  numberstyle={\footnotesize},% 行番号のスタイル
  xleftmargin=15pt,% 左余白
  xrightmargin=5pt,% 右余白
  keepspaces=true,% 空白を維持する
  mathescape,% $ で囲った部分を数式として表示する ($ がソースコード中で使えなくなるので注意)
  % 手動強調表示の設定
  moredelim=[is][\bfseries]{@*}{*@},
  moredelim=[is][\itshape]{@/}{/@}
}

%% ===============================================
%% 論文中で使う記号とかのマクロ定義
%% ===============================================

%% 論文中で繰り返し使う記号は次のように「マクロ」として実装しておくと良い。
%% TeX ソース中で \BOOL と書くと、\texttt{Bool} に置き換えてくれる。
%% フォントを変え忘れたりするリスクが減るし、あとから記号を変更するのも楽になる。

\newcommand{\keyword}[1]{\mathbf{#1}}
\newcommand{\BOOL}{\keyword{Bool}}
\newcommand{\TRUE}{\keyword{true}}
\newcommand{\FALSE}{\keyword{false}}
\newcommand{\IF}{\keyword{if}}
\newcommand{\THEN}{\keyword{then}}
\newcommand{\ELSE}{\keyword{else}}
\newcommand{\LET}{\keyword{let}}
\newcommand{\REC}{\keyword{rec}}
\newcommand{\ARRAY}{\keyword{Array}}
\newcommand{\CREATE}{\keyword{create}}
\newcommand{\AND}{\keyword{and}}
\newcommand{\IN}{\keyword{in}}
\newcommand{\WHILE}{\keyword{while}}
\newcommand{\DO}{\keyword{do}}
\newcommand{\DONE}{\keyword{done}}

\begin{document}
\maketitle

\begin{abstract}
コンパイラのバグは生成したコードに波及するため影響が大きく，正当性の証明が盛んに試みられてきた．
一方そのような先行研究では，対象言語に存在するIO，要素数が可変の構文といった機構が正当性の証明を困難にしていた．

MinCamlは非純粋な関数型言語のコンパイラであるが，IO，要素数が可変の構文を含んでおり，
もしMinCamlを検証できた場合に得られる知見は対象言語に同様の機構を持つ処理系を検証する際にも有用であると考えられる．
将来的にMinCamlにおけるK正規化処理の正当性を形式的に検証する事を目標とし，
本研究では型なし$\lambda$計算に算術演算，if，letといったプリミティブを追加した，
MinCamlのサブセットにあたる言語におけるK正規化処理の正当性を，定理証明支援系の一つであるCoqを用いて検証する．

また，本研究ではコンパイラの検証をする上での負担を和らげるべく，対象言語の意味論を余帰納的大ステップ意味論を用いて定義し，
束縛をde Bruijnインデックスを用いて表現する．
これにより，停止しないかもしれないプログラムの正当性の定理証明においても，理論的な簡単さと証明の簡潔さの両立が可能となる．

コンパイラの正当性の証明は対象言語に対するスケーラビリティが低くなりがちであるが，
本研究ではCoqの証明自動化に関する機能を用いる事でこの問題の解決を図る．
これにより，型なし$\lambda$計算におけるK正規化の正当性の証明に110行のスクリプトを要するのに対し，
対象言語に算術演算，if，letといったプリミティブを追加した場合にも正当性の証明に要するスクリプトは141行に留められる．
\end{abstract}

\chapter*{謝辞}

圧倒的感謝

%% 目次
\tableofcontents

%% ここから本文

\chapter{序論}

%% 参考文献は \cite{ID} とします（ID は refs.bib 内で文献につけた識別子）
%% BibTeX の使い方などは各自調べて下さい。

\section{研究背景}

プログラムのバグが計り知れない社会的損失をもたらす事は良く知られており，
ソフトウェア開発においてデバッグは不可欠な存在となっている．
中でもコンパイラのバグは深刻であり，
コンパイラにバグがあれば与えられたソースコードにバグが無くてもバグを含んだコードが出力されてしまう．
このようにして発生したバグを発見するにはソースコードを精査するだけではなく，
コンパイラによって生成されたコードを確認する必要があるため，
ソースコード由来のバグを発見するより困難である．

そのため定理証明支援系を用いたコンパイラの正当性の証明が盛んに試みられてきた．
その中でも成功した研究として，LeroyらによるCompCert\cite{2006-Leroy-Blazy-Dargaye}が挙げられる．
これはC言語のほとんどをカバーする機能を持ったサブセットのコンパイラをCoqによって検証する試みである．
C言語にはIOの機能が含まれているため，CompCertの対象言語にもIOの機能が含まれている．
その一方，C言語の関数は複数の引数を取れるが，
CompCertの対象言語は部分式に関数呼び出しを許さないようにして要素数が可変の構文に制限を設けている．

本研究と類似した，純粋でない関数型言語を対象言語としたコンパイラの検証には
Chlipalaの研究\cite{ImpurePOPL10}が挙げられる．
その対象言語は高階関数，参照，二つ組といった機能を有している一方，
組を二つ組に限定して要素数が可変の構文を含まないようになっている他，
IOを扱う機能も存在しない．

検証を難しくするために要素数が可変な構文やIOといった対象言語の機構は忌避されがちであるが，
住井による教育用コンパイラMinCaml\cite{DBLP:conf/icfp/Sumii05}は非純粋な関数型言語を対象とするほか，これらの機構を備えている．
もしMinCamlを検証できれば，そこで得られる知見は対象言語に同様の機構を持つ処理系を検証する際にも有用であると考えられる．

\section{本研究の貢献}

将来的にMinCamlにおけるK正規化処理の正当性を形式的に検証する事を目標とし，
本研究では型なし$\lambda$計算に算術演算，if，letといったプリミティブを追加した，
MinCamlのサブセットにあたる言語におけるK正規化処理の正当性を，定理証明支援系の一つであるCoqを用いて検証する．
その際，Coqの証明自動化に関する機能を用いる事で対象言語に対する証明のスケーラビリティを確保する．

また，証明のスケーラビリティを評価するため，
型なし$\lambda$計算を対象言語としたK正規化処理の正当性も検証し，
対象言語に算術演算，if，letといったプリミティブを追加した場合と証明の行数を比較する．

\section{本論文の構成}

\chapter{MinCaml}

住井による教育用コンパイラ\cite{DBLP:conf/icfp/Sumii05}
\begin{itemize}
	\item 非純粋な関数型言語
	\item OCamlで2000行程度の実装
		\begin{itemize}
			\item 型推論
			\item 定数畳み込み等の最適化
		\end{itemize}
\end{itemize}

\section{対象言語}
MinCamlの対象言語
\begin{itemize}
	\item 高階関数
	\item N引数の構文
	\item 副作用
	\item 外部関数呼び出し(入出力)
\end{itemize}

	\[
	\begin{array}{l}
		M, N, f ::= \\
		\qquad \qquad \vdots\\
		\qquad \LET~\REC~x~y_1~\cdots~y_n=M~\IN~N\\
		\qquad f~N_1~\cdots~N_n\\
		\qquad (M_1,~\cdots~,M_n)\\
		\qquad \LET~(M_1,~\cdots~,M_n)=M~\IN~N\\
		\qquad \ARRAY.\CREATE~M~N\\
		\qquad M_1.(M_2)\\
		\qquad M_1.(M_2)\leftarrow M_3\\
	\end{array}
	\]

\section{内部設計}
\begin{itemize}
	\item 様々なコンパイルフェーズ
	\item 疎結合
\end{itemize}

\section{K正規化}
全ての部分式に名前を付ける

\begin{center}
	$a+b*c+d$
\end{center}

\begin{center}
	\[
		\begin{array}{l}
			\LET~x = b * c~\IN \\
			\LET~y = a + x~\IN \\
			y + d
		\end{array}
	\]
\end{center}

\vfill

束縛に関する操作

	K正規化後の項を評価してみる

	\vfill

	単純な値では一致
			\[ 1+2\Downarrow 3 \]
			\[ 
				\begin{array}{l}
					\LET~a = 1~\IN \\
					\LET~b = 2~\IN \\
					a + b\Downarrow 3
				\end{array}
			\]

	\vfill

	元の値のK正規形と一致
			\[
				\begin{array}{l}
					\lambda x.\lambda y.\lambda z.~x+y+z\\
					\Downarrow \lambda x.\lambda y.\lambda z.~x+y+z
				\end{array}
			\]
			\[ 
				\begin{array}{l}
					\lambda x.\lambda y.\lambda z.\\
					\LET~a = x+y~\IN \\
					a + z \\
					\Downarrow \lambda x.\lambda y.\lambda z.\\
					\LET~a = x+y~\IN \\
					a + z \\
				\end{array}
			\]

	\begin{theorem}
		項tが値vに評価される場合、項tをK正規化した結果K(t)は値vをK正規化した結果K(v)に評価される
	\end{theorem}
	\begin{theorem}
		項tの評価が停止しない場合、項tをK正規化した結果K(t)の評価は停止しない
	\end{theorem}
	今回検証した言語の範囲では評価は決定的なため、逆も成り立つ

\chapter{束縛の表現}

\section{名前による表現}
	$\alpha$等価性の議論が面倒
	\[ \lambda x.\lambda y.~x \simeq \lambda a.\lambda b.~a \]

	\vfill

	freshな名前が必要になる
	\begin{itemize}
		\item 束縛の関係を乱さないよう変数名を選ぶ
	\end{itemize}
	\[
		\begin{array}{lcl}
			[x \mapsto z](\lambda z.~x) & \simeq & \lambda z'.~z \\
																	& \not \simeq & \lambda z.~z
		\end{array}
	\]

\section{de Bruijnインデックス}
	何番目の束縛かで変数を表現
	\begin{itemize}
		\item 内側から外側へ数える
	\end{itemize}
			\[ \lambda x. \lambda y. \lambda z.~x z (y z) \]
			\[ \lambda. \lambda. \lambda.~2~0~(1~0) \]

	\vfill

	$\alpha$等価な式は構文的に等価
	\begin{itemize}
		\item 名前のfreshnessを保証
	\end{itemize}
			\[ \lambda x.\lambda y.~x \]
			\[ \lambda a.\lambda b.~a \]
			\[ \lambda.\lambda.~1 \]

	自由変数のインデックスをずらす
	\[\uparrow^d t \]

	束縛に関する操作
			\[ (\lambda x.~x)~(\lambda x.~y) \]
			\[ (\lambda.~0)~(\lambda.~1) \]

	\vfill

			\[ 
					\begin{array}{l}
						\LET~a = \lambda x.~x~\IN \\
						\LET~b = \lambda x.~y~\IN \\
						a~b
					\end{array}
			\]
			\[
				\begin{array}{l}
					\LET~\_ = \lambda.~0~\IN \\
					\LET~\_ = \uparrow^1(\lambda.~1)~\IN \\
					1~0
				\end{array}
			\]

K正規化の実装
\begin{lstlisting}[basicstyle={\ttfamily\normalsize}]
Fixpoint knormal e :=
  match e with
  | Exp.Var x => K.Var x
  | Exp.Abs e => K.Abs (knormal e)
  | Exp.App e1 e2 =>
      K.Let (knormal e1)
        (K.Let (shift 1 (knormal e2))
          (App 1 0))
  end.
\end{lstlisting}

\section{その他の表現方法}

PHOAS


Locally nameless representation


\chapter{意味論}\label{chapter:semantics}

\section{小ステップ意味論}

\section{大ステップ意味論}
	\begin{center}
	比較的単純な\\プログラム変換の検証に適する

	\vfill

	が

	\vfill

	無限ループとエラーの区別が困難
	\end{center}

	例:型無しラムダ計算

	構文
			\[
				\begin{array}{lcl}
					t & ::= & b \\
					  & | & x \\
						& | & \lambda x.~t \\
						& | & t~t
				\end{array}
			\]
			\[
				\begin{array}{lcl}
					v & ::= & b \\
						& | & \lambda x.~t \\
				\end{array}
			\]

	\vfill

	意味論
			\[\overline{b \Downarrow b}\]
			\[\overline{\lambda x.~t \Downarrow \lambda x.~t}\]

	\begin{prooftree}
		\AxiomC{$t_1 \Downarrow \lambda x.~t$}
		\AxiomC{$t_2 \Downarrow v_2$}
		\AxiomC{$[x \mapsto v_2]t \Downarrow v$}
		\TrinaryInfC{$t_1~t_2 \Downarrow v$}
	\end{prooftree}

	余帰納的大ステップ意味論(1/2)

	余帰納的に定義 [Leroy及びGrall 2009]
			\begin{prooftree}
				\AxiomC{$t_1 \Uparrow$}
				\doubleLine
				\UnaryInfC{$t_1~t_2 \Uparrow$}
			\end{prooftree}
			\begin{prooftree}
				\AxiomC{$t_1 \Downarrow v_1$}
				\AxiomC{$t_2 \Uparrow$}
				\doubleLine
				\BinaryInfC{$t_1~t_2 \Uparrow$}
			\end{prooftree}

	\vfill

	\begin{prooftree}
		\AxiomC{$t_1 \Downarrow \lambda x.~t$}
		\AxiomC{$t_2 \Downarrow v_2$}
		\AxiomC{$[x \mapsto v_2]t \Uparrow$}
		\doubleLine
		\TrinaryInfC{$t_1~t_2 \Uparrow$}
	\end{prooftree}

			エラー
			\[ \TRUE~\TRUE \not \Uparrow \]
			適用できる規則がない

			無限ループ
			\[ (\lambda x.x x)(\lambda x.x x) \Uparrow \]
			無限回の規則適用を許す

	\vfill

	\begin{center}
		区別できる
	\end{center}

\chapter{Coqによる形式的検証}

\section{コンパイラの検証}
	言語拡張のたび全ての証明の修正が必要
\begin{lstlisting}[frame=none]
Inductive t :=
  | Var : nat -> t
$\vdots$
Proof.
  intros t.
  induction t.
  Case "Var".
\end{lstlisting}

\begin{lstlisting}[frame=none]
Inductive t :=
  @r{| Int : Z -> t}@
  | Var : nat -> t
$\vdots$
Proof.
  intros t.
  induction t.
  @r{Case "Int".}@
    $\vdots$
  Case "Var".
\end{lstlisting}

Coqの証明自動化機能
	構文の違いを自動証明で吸収
	\begin{center}
		\begin{itemize}
			\item $\mathit{tactic}_1;\mathit{tactic}_2$
			\item $\keyword{solve} [\mathit{tactic}_1 | \cdots | \mathit{tactic}_n]$
		\end{itemize}
	\end{center}

	\vfill

\begin{lstlisting}[]
Lemma shift_0 : forall e c,
  shift c 0 e = e.
Proof.
  intros e.
  induction e; intros ?; simpl;
    f_equal;
    solve [ apply shift_var_0 | eauto ].
Qed.
\end{lstlisting}


\section{正当性の検証}
\section{言語の拡張}

	拡張性の評価
	プリミティブ、if、letを追加
	\begin{center}
		\begin{tabular}{l|ll}
			 & 構文 & 証明の行数 \\
			\hline
			拡張前 & 変数 匿名関数 関数適用 & 110 \\
			拡張後 & 20種類 & 141 \\
		\end{tabular}
	\end{center}

	\vfill

	単純な変更に対してはスケール

\chapter{結論}
	K正規化をCoqで検証できた
	\begin{itemize}
		\item de Buijnインデックス、\\余帰納的大ステップ意味論の採用で証明が簡潔に
		\item 証明自動化による再利用性の高い証明
	\end{itemize}

	今後の課題
	さらに言語を拡張し、MinCamlと同等に
	\begin{itemize}
		\item 組や複数引数の関数
		\item 配列
		\item 外部関数呼び出し
	\end{itemize}

	\vfill

	K正規化以外の検証も

\chapter{議論・関連研究}

\section{BNF の書き方の例}

本節では、BNF によるプログラミング言語の構文の書き方を紹介する。
構文木の書き方は一つというわけではないので、幾つかのバリエーションを紹介する。
どの方法が良いと思うかは、個人の好みに依るところなので、好きなものを使えば良いと思う。

まず、次の方法では、array 環境を使って、BNF を書いている。
array 環境は数式環境中で表のようなものを書くときに使う。
基本的に、table 環境と使い方は同じである。
\[
%% 空白を明示的に開けるときは "\," "\ " "~" "\quad" "\qquad" などを使う。
%% 空白の幅は "\qquad" > "\quad" > "~" = "\ " > "\," の順で大きい。
%% "~" と "\ " は空白の代わりに改行を許すかどうかの違い（"\ " だと改行される可能性がある）
\begin{array}{rl@{\qquad\qquad}r}
  t ::=
  & & \mbox{terms:} \\
  & x & \mbox{variables} \\
  & \lambda x.~t & \mbox{lambda abstraction} \\
  & t_1~t_2 & \mbox{application} \\
  & \TRUE & \mbox{true} \\
  & \FALSE & \mbox{false} \\
  & \IF~t_1~\THEN~t_2~\ELSE~t_3 & \mbox{if statement}
\end{array}
\]

他にも、次のように、align 環境を使っても、似たようなものを書くことができる。
\begin{align}
  t ::=
  & \tag*{terms:} \\
  & x \tag*{variables} \\
  & \lambda x.~t \tag*{lambda abstraction} \\
  & t_1~t_2 \tag*{application} \\
  & \TRUE \tag*{true} \\
  & \FALSE \tag*{false} \\
  & \IF~t_1~\THEN~t_2~\ELSE~t_3 \tag*{if statement}
\end{align}
array 環境を愚直に使う場合と比べて、式が中央揃えになるという点と、
``variables'' とかの説明が右端に来ている点が違う。
説明は tag* マクロで出しており、これはもともと式番号を指定するためのものなので、
若干使い方がおかしい気もするが、まぁ、いいだろう。
自分の好みの方を使うと良いだろう。

BNF 全体を左揃えにしたいならば、次のように、flalign 環境を使うと良い。
align 環境と違って、\verb|&| を余分に1つ付ける必要がある、ということに注意して欲しい（詳しくはソースコードを見よ）。
\begin{flalign}
  t ::=
  & & \tag*{terms:} \\ % & を余分に1つ付けること！
  & x \tag*{variables} \\
  & \lambda x.~t \tag*{lambda abstraction} \\
  & t_1~t_2 \tag*{application} \\
  & \TRUE \tag*{true} \\
  & \FALSE \tag*{false} \\
  & \IF~t_1~\THEN~t_2~\ELSE~t_3 \tag*{if statement}
\end{flalign}

\section{導出木の書き方の例}

導出木の書き方も色々あるが、ここでは、bussproofs.sty を使った方法を紹介する。
導出木は、手書きでも書きにくいが、\LaTeX だから書きやすいというわけでもなく、
（使うパッケージにも依るが）そこそこの苦労は必要である。
bussproofs.sty を除く多くの方法では、frac などをベースに「分数」で導出木を書く。
bussproofs.sty はこれらとは全く異なるインタフェースであり、慣れれば比較的解りやすい。
bussproofs.sty の動作は、（導出木を要素とする）スタックをイメージすると解りやすい。
よく使うマクロは次の通り。
\begin{itemize}
\item \lstinline|\AxiomC{...}|：Axiom を push する（導出木では葉に相当）
\item \lstinline|\UnaryInfC{...}|：スタックから部分導出木（仮定）を1つ pop して、
  それを新たに作ったノード（結論）の子供にすることで、新たな部分導出木を作成し、push する。
\item \lstinline|\BinaryInfC{...}|：スタックから部分導出木（仮定）を2つ pop して、
  \lstinline|\UnaryInfC| と同様の動作を行う。
\item \lstinline|\TrinaryInfC{...}|：スタックから部分導出木（仮定）を3つ pop して、
  \lstinline|\UnaryInfC| と同様の動作を行う。
\end{itemize}

実際の使い方は以下の通り。

%% T-Var
\begin{prooftree}
  \AxiomC{$x:T \in \Gamma$}
  \RightLabel{\textsc{T-Var}}
  \UnaryInfC{$\Gamma \vdash x : T$}
\end{prooftree}
%% T-Abs
\begin{prooftree}
  \AxiomC{$\Gamma, x:T \vdash t : U$}
  \RightLabel{\textsc{T-Abs}}
  \UnaryInfC{$\Gamma \vdash \lambda x.~t : T \to U$}
\end{prooftree}
%% T-App
\begin{prooftree}
  \AxiomC{$\Gamma \vdash t_1 : T \to U$}
  \AxiomC{$\Gamma \vdash t_2 : T$}
  \RightLabel{\textsc{T-App}}
  \BinaryInfC{$\Gamma \vdash t_1~t_2 : U$}
\end{prooftree}

\begin{prooftree}
  \AxiomC{}
  \RightLabel{\textsc{T-True}}
  \UnaryInfC{$x : \BOOL \to \BOOL \vdash \TRUE : \BOOL$}
  \RightLabel{\textsc{T-Abs}}
  \UnaryInfC{$\vdash \lambda x.~\TRUE : (\BOOL \to \BOOL) \to \BOOL$}
  \AxiomC{$y : \BOOL \in y : \BOOL$}
  \RightLabel{\textsc{T-Var}}
  \UnaryInfC{$y : \BOOL \vdash y : \BOOL$}
  \RightLabel{\textsc{T-Abs}}
  \UnaryInfC{$\vdash \lambda y.~y : \BOOL \to \BOOL$}
  \RightLabel{\textsc{T-App}}
  \BinaryInfC{$\vdash (\lambda x.~\TRUE)~(\lambda y.~y) : \BOOL$}
\end{prooftree}

\section{定理環境}

この論文クラスファイルでは、デフォルトで以下の定理環境を提供している。

\begin{theorem}[定理のタイトル]
  定理の内容
\end{theorem}

\begin{lemma}[補題のタイトル]
  補題の内容
\end{lemma}

\begin{corollary}[系のタイトル]
  系の内容
\end{corollary}

\begin{proposition}[命題のタイトル]
  命題の内容
\end{proposition}

\begin{definition}[定義のタイトル]
  定義の内容
\end{definition}

\begin{example}[例のタイトル]
  例の内容
\end{example}

\begin{assumption}[仮定のタイトル]
  仮定の内容
\end{assumption}

\begin{axiom}[公理のタイトル]
  公理の内容
\end{axiom}

\begin{proof}[証明のタイトル]
  証明の内容 \qed
\end{proof}

\begin{proof*}[証明のタイトル]
  証明の内容（番号なしの証明環境。証明を \lstinline|\ref| で参照する必要がないなら、こっちを使うほうが自然かも） \qed
\end{proof*}

\subsection{定理環境の使い方の例}

\begin{lemma}
  \label{lem:interesting-lemma}
  論文の中で最重要とは言えないような性質・命題は補題 (lamma) にする。
  補題や定理から直ちに導けるような軽い命題は系 (corollary) にする（細かい使い分けは人による）。
\end{lemma}

\begin{proof*}
  \lstinline|proof*| のように、アスタリスク付きの環境では、番号が付かない。
\end{proof*}

\begin{theorem}
  \label{thm:wonderful-theorem}
  提案手法の最も重要な性質や命題は、定理 (theorem) として書く。
  読者の心をくすぐる興味深いステートメントを書こう。
\end{theorem}

\begin{proof*}
  定理 \ref{thm:wonderful-theorem} の華麗な証明。その美しい証明に、読者の目は釘付けだ！
  \begin{enumerate}[leftmargin=0pt,itemindent=*,label=Case \arabic*.]
  \item 自明
  \item 補題 \ref{lem:interesting-lemma} から直ちに導ける。
  \item 言うまでもない。目を瞑れば証明が見えてくる。
  \item あんまり自明じゃない
    \begin{enumerate}[label=(\roman*)]
    \item 自明じゃないと思ったけど、やっぱり自明だった
    \item ほらね、こんなに簡単
    \end{enumerate}
  \end{enumerate}
\end{proof*}

\section{ソースコード}

ソースコード\ref{src:listup_nodes}は二分木を深さ優先探索して、ノードを列挙する関数である。
\begin{lstlisting}[caption=二分木のノードのリストアップ,label=src:listup_nodes]
type 'a bin_tree =
  | Leaf of 'a
  | Node of 'a bin_tree * 'a bin_tree

let rec listup_nodes = function
  | Leaf x -> [x]
  | Node (r, l) -> (listup_nodes r) @ (listup_nodes l)
\end{lstlisting}
ソースコードの書き方等については slide ブランチの slide.tex を参照されたし。

\chapter{結論}

%% 参考文献: bibtex
\bibliographystyle{junsrt}
\bibliography{refs}

\end{document}
