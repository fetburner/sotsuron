\documentclass[dvipdfmx,cjk,xcolor=dvipsnames,envcountsect,notheorems,12pt]{beamer}
% * 16:9 のスライドを作るときは、aspectratio=169 を documentclass のオプションに追加する
% * 印刷用の配布資料を作るときは handout を documentclass のオプションに追加する
%   （overlay が全て一つのスライドに出力される）

\usepackage{pxjahyper}% しおりの文字化け対策 (なくても良い)
\usepackage{amsmath,amssymb,amsfonts,amsthm,ascmac,cases,bm,pifont}
\usepackage{graphicx}
\usepackage{bussproofs}
\usepackage{url}
\usepackage{etex}
\usepackage{fancybox}
\usepackage{newtxmath}
\usepackage{tikz}
\usepackage{pxpgfmark}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.callouts}

% スライドのテーマ
\usetheme{sumiilab}
% ベースになる色を指定できる
%\usecolortheme[named=Magenta]{structure}
% 数式の文字が細くて見難い時は serif の代わりに bold にしましょう
%\mathversion{bold}

%% ===============================================
%% スライドの表紙および PDF に表示される情報
%% ===============================================

%% 発表会の名前とか（省略可）
\session{日本ソフトウェア科学会第33回大会}
%% スライドのタイトル
\title{無限の入出力を行う\\関数型プログラムのK正規化の\\形式的検証}
%% 必要ならば、サブタイトルも
%\subtitle{}
%% 発表者のお名前
\author{水野雅之　住井英二郎}
%% 発表者の所属（[] 内は短い名前）
% \institute[東北大学　住井・松田研]{工学部　情報知能システム総合学科\\住井・松田研究室}% 学部生
\institute[東北大学　住井・松田研]{東北大学 大学院情報科学研究科}% 院生
%% 発表する日
\date{2016年9月9日}

%% ===============================================
%% 自動挿入される目次ページの設定（削除しても可）
%% ===============================================

%% section の先頭に自動挿入される目次ページ（削除すると、表示されなくなる）
\AtBeginSection[]{
\begin{frame}
  \frametitle{アウトライン}
  \tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/show/hide]
\end{frame}}
%% subsection の先頭に自動挿入される目次ページ（削除すると、表示されなくなる）
\AtBeginSubsection[]{
\begin{frame}
  \frametitle{アウトライン}
  \tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
\end{frame}}

%% 現在の section 以外を非表示にする場合は以下のようにする

%% \AtBeginSection[]{
%% \begin{frame}
%%   \frametitle{アウトライン}
%%   \tableofcontents[sectionstyle=show/hide,subsectionstyle=show/show/hide]
%% \end{frame}}
%% \AtBeginSubsection[]{
%% \begin{frame}
%%   \frametitle{アウトライン}
%%   \tableofcontents[sectionstyle=show/hide,subsectionstyle=show/shaded/hide]
%% \end{frame}}

%% ===============================================
%% 定理環境の設定
%% ===============================================

\setbeamertemplate{theorems}[numbered]% 定理環境に番号を付ける
\theoremstyle{definition}
\newtheorem{definition}{定義}
\newtheorem{axiom}{公理}
\newtheorem{theorem}{定理}
\newtheorem{lemma}{補題}
\newtheorem{corollary}{系}
\newtheorem{proposition}{命題}
\newtheorem{hypothesis}{仮説}

%% ===============================================
%% ソースコードの設定
%% ===============================================

\usepackage{listings,jlisting}
%\usepackage[scale=0.9]{DejaVuSansMono}

\definecolor{DarkGreen}{rgb}{0,0.5,0}
% プログラミング言語と表示するフォント等の設定
\lstset{
  language={[Objective]Caml},% プログラミング言語
  basicstyle={\ttfamily\small},% ソースコードのテキストのスタイル
  keywordstyle={\bfseries},% 予約語等のキーワードのスタイル
  commentstyle={},% コメントのスタイル
  stringstyle={},% 文字列のスタイル
  frame=trlb,% ソースコードの枠線の設定 (none だと非表示)
  numbers=none,% 行番号の表示 (left だと左に表示)
  numberstyle={},% 行番号のスタイル
  xleftmargin=5pt,% 左余白
  xrightmargin=5pt,% 右余白
  keepspaces=true,% 空白を表示する
  mathescape,% $ で囲った部分を数式として表示する ($ がソースコード中で使えなくなるので注意)
  % 手動強調表示の設定
  moredelim=[is][\itshape]{@/}{/@},
  moredelim=[is][\color{red}]{@r\{}{\}@},
  moredelim=[is][\color{blue}]{@b\{}{\}@},
  moredelim=[is][\color{DarkGreen}]{@g\{}{\}@},
}

\newcommand{\keyword}[1]{\mathbf{#1}}
\newcommand{\LET}{\keyword{let}}
\newcommand{\IF}{\keyword{if}}
\newcommand{\THEN}{\keyword{then}}
\newcommand{\ELSE}{\keyword{else}}
\newcommand{\FIX}{\keyword{fix}}
\newcommand{\CREATE}{\keyword{create}}
\newcommand{\AND}{\keyword{and}}
\newcommand{\IN}{\keyword{in}}
\newcommand{\TRUE}{\keyword{true}}
\newcommand{\WHILE}{\keyword{while}}
\newcommand{\DO}{\keyword{do}}
\newcommand{\DONE}{\keyword{done}}

%% ===============================================
%% 本文
%% ===============================================
\begin{document}
\frame[plain]{\titlepage}% タイトルページ

\begin{frame}
	\frametitle{背景：コンパイラの形式的検証の意義}
	\begin{center}
		\LARGE 
		\begin{columns}
			\begin{column}{0.8\textwidth}
				\begin{itembox}[c]{コンパイラのバグ}
					\begin{itemize}
						\item 生成されるコードに影響
						\item デバッグが困難
					\end{itemize}
				\end{itembox}
			\end{column}
		\end{columns}
		$\Downarrow$\\
		形式的検証が有用
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{背景:既存研究(1/2)}
	\begin{itemize}
		\item 高階関数がない
			\begin{itemize}
				\item CompCert [Leroy+ 2006]
					\begin{itemize}
						\item Cコンパイラの正当性の検証
					\end{itemize}
			\end{itemize}
		\item 入出力がない
			\begin{itemize}
				\item Lambda Tamer [Chlipala 2010]
					\begin{itemize}
						\item 非純粋高階関数型言語処理系の\\正当性の検証
					\end{itemize}
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{背景:既存研究(2/2)}
	\begin{itemize}
		\item 高階関数も入出力もある
			\begin{itemize}
				\item Pilsner [Neis+ 2015]
					\begin{itemize}
						\item ソース言語の束縛は名前で表現
						\item 小ステップ意味論
						\item 論理関係
					\end{itemize}
				\item CakeML [Tan+ 2016]
					\begin{itemize}
						\item ソース言語の束縛は名前で表現
						\item 中間言語の束縛はde Bruijnインデックスで表現
						\item クロックを用いた大ステップ意味論
					\end{itemize}
			\end{itemize}
	\end{itemize}
	\begin{flushright}
		\Large $\Rightarrow$後で手法を比較
	\end{flushright}
\end{frame}

\begin{frame}
	\frametitle{本研究の概要}
	\begin{itemize}
		\item 入出力を含む\\高階関数型言語処理系を検証
			\begin{itemize}
				\item 本研究ではK正規化パスのみを検証
				\item 余帰納的大ステップ意味論\mbox{[Leroy, Grall 2009]}
					\begin{itemize}
						\item 無限に入出力が続く場合の検証が簡潔
					\end{itemize}
				\item de Buijnインデックス
					\begin{itemize}
						\item 束縛の表現が簡潔
					\end{itemize}
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{K正規化}
	\LARGE
	\begin{itemize}
		\item 全ての部分式に名前を付ける\\（K正規形への）変換
	\end{itemize}

	\vfill

	例:
	\begin{columns}
		\begin{column}{0.3\textwidth}
			$a+b*c+d$
		\end{column}
		\begin{column}{0.1\textwidth}
			$\Rightarrow$
		\end{column}
		\begin{column}{0.5\textwidth}
			\tikz[remember picture]{\node(let-insertion){
				$\begin{array}{l}
					\alert<2>{\LET~x =} b * c~\alert<2>{\IN} \\
					\alert<2>{\LET~y =} a + x~\alert<2>{\IN} \\
					y + d
				\end{array}$};}
		\end{column}
	\end{columns}
	\pause
	\begin{tikzpicture}[remember picture, overlay]
		\node[rectangle callout, fill=red!80, white, callout absolute pointer={(let-insertion.north)}, above=of let-insertion]{束縛が導入される};
	\end{tikzpicture}
\end{frame}

\section*{アウトライン}

% 目次を表示させる（section を表示し、subsection は隠す）
%\begin{frame}
%  \frametitle{アウトライン}
%  \tableofcontents[sectionstyle=show,subsectionstyle=hide]
%\end{frame}

\section{対象言語}

\begin{frame}
	\frametitle{値呼びの型無し$\lambda$計算の拡張}
	{\large
	\[ \begin{array}{lcll}
		e & ::= & c & \mbox{定数（整数$\cdot$真偽値）} \\
				& | & e_1 \odot e_2 & \mbox{算術演算（$+, -, \times, \leq$）} \\
				& | & \IF~e_1~\THEN~e_2~\ELSE~e_3 & \mbox{条件分岐} \\
				& | & \alert<4>{\LET~x=e_1~\IN~e_2} & \alert<4>{\mbox{変数定義}} \\
				& | & \alert<5>{x} & \alert<5>{\mbox{変数$\cdot$外部関数}} \\
				& | & \alert<6, 7>{\FIX~f~x.~e} & \alert<6, 7>{\mbox{再帰関数}} \\
				& | & \alert<7>{e_1~e_2} & \alert<7>{\mbox{関数呼び出し}} \\
				& | & \alert<7>{(e_1,~e_2)} & \alert<7>{\mbox{二つ組の作成}} \\
				& | & \pi_i~e & \mbox{射影}(i \in \{0, 1\}) \\
	\end{array} \]}
	\Large
	\only<4>{{\normalsize 型無しのため$(\lambda x.~e_2)~e_1$としても表現できるが}\\
		\alert<4>{K正規形を表現するために導入}}
	\only<5>{\alert<5>{自由変数への関数適用}(e.g. $\texttt{print\_int}~42$)\\
		\alert<5>{は外部関数の呼び出しとみなす}
		\begin{itemize}
			\item 入出力は外部関数呼び出しで表現
		\end{itemize}}
	\only<6>{{\normalsize 型無しのため不動点コンビネータでも表現できるが}\\
		\alert<6>{実用されている言語に近付けるために採用}}
	\only<7>{\alert<7>{n-aryな構文を制限}
		\begin{itemize}
			\item 理由は後で述べる
		\end{itemize}}
\end{frame}

\section{問題点$\textcircled{\footnotesize 1}$束縛の表現}

\begin{frame}
	\frametitle{名前による表現の問題点}
	\LARGE 項の等価性がCoqの等価性でなく\\$\alpha$等価性となる
	\[ \lambda x.\lambda y.~x \simeq \lambda a.\lambda b.~a \]

	\vfill

	捕獲を避ける必要がある
	\begin{itemize}
		\item 束縛の関係を乱さないよう変数名を選ぶ
	\end{itemize}
	\[\begin{array}{l}
		K(\lambda z.~x+y+z) \\
		\not \simeq \lambda z.~\LET~z=x+y~\IN~z+z
	\end{array}\]
\end{frame}

\begin{frame}
	\frametitle{我々の解決策:de Bruijnインデックス}
	\LARGE
	何番目の束縛かで変数の出現を表現
	\begin{itemize}
		\item 内側から外側へ数える
	\end{itemize}
	\begin{columns}
		\begin{column}{0.4\textwidth}
			$\lambda x.~x~(\lambda y.~x~y)$
		\end{column}
		\begin{column}{0.1\textwidth}
			$\Rightarrow$
		\end{column}
		\begin{column}{0.4\textwidth}
			$\lambda.~0~(\lambda.~1~0)$
		\end{column}
	\end{columns}

	\vfill

	$\alpha$等価な式は文面上も同じ
	\begin{columns}
		\begin{column}{0.4\textwidth}
			\begin{center}
				$\lambda x.\lambda y.~x$\\
				$\lambda a.\lambda b.~a$
			\end{center}
		\end{column}
		\begin{column}{0.1\textwidth}
			$\Rightarrow$
		\end{column}
		\begin{column}{0.4\textwidth}
			$\lambda.\lambda.~1$
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{de Bruijnインデックスを用いたK正規化の実装}
	{\Large \[K(\lambda z.~x+y+z) = \lambda z.~\LET~a=x+y~\IN~a+z \]
	\[\Downarrow\]
	\[ K(\lambda.~2+1+0) = \lambda.~\LET~2+1~\IN~0+\alert{1}\]}
	\vfill
	\begin{center}\LARGE 
		\alert{インデックスをずらす必要がある}
		\[\Downarrow\]
		シフトを用いる
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{シフト}
	\LARGE 自由変数のインデックスをずらす\\
	凡例:$\uparrow^d t$
	\vfill
	\[\uparrow^1(0~(\lambda.~0~1)) = 1~(\lambda.~0~2)\]
	\vfill
	束縛に関する操作で必要
\end{frame}

\begin{frame}
	\frametitle{本研究での自由変数の表現}
	\LARGE
	自由変数は名前で表現
	\vfill
	{\LARGE \[(\FIX~f~x.~\texttt{print\_int}~x)~42\]
	\[\Downarrow\]
	\[(\FIX.~\texttt{print\_int}~1)~42\]}
\end{frame}

\begin{frame}
	\frametitle{関連研究の例:局所名前無し表現}
	\LARGE 自由変数は名前で表現

	\vfill 

	シフトの代わりにopenとclose
	\[\begin{array}{lcl}
		\lambda.~e & \xrightarrow{\texttt{open}} & [0 \mapsto z]e \\
		e & \xrightarrow{\texttt{close}} & \lambda.~[z \mapsto 0]e \\
	\end{array}\]
\end{frame}

\begin{frame}
	\frametitle{局所名前無し表現の問題点}
	\LARGE well-formedである証明が必要
	\begin{itemize}
		\item locally closed
	\end{itemize}

	\vfill

	{\large \[\begin{array}{rcl}
		K(e_1~e_2) & \equiv & \LET~ K(e_1)~\IN~\LET~K(e_2)~\IN~1~0 \\
		K(\lambda.~e) & \equiv & \lambda.~[x\mapsto 0](K([0\mapsto x]e)) \\
	\end{array}\]}
	帰納的定義に証明が必要
\end{frame}

\begin{frame}
	\frametitle{(パラメトリック)高階抽象構文}
	\LARGE
	ホスト言語の束縛を流用
	\[\texttt{Abs}~(\texttt{fun}~x \Rightarrow \texttt{Var}~x)\]

	\begin{itemize}
		\item 名前の付け替えや代入をホスト言語に任せられる
		\item ホスト言語のparametricityの証明が必要
	\end{itemize}
\end{frame}

\section{問題点\textcircled{\footnotesize 2}無限の入出力}

\begin{frame}
	\frametitle{問題点\textcircled{\footnotesize 2}無限の入出力:有限の入出力の場合}
	\Large
	大ステップ意味論を入出力の列で拡張
	\begin{center}
		凡例:$e \Downarrow v~/~t$
	\end{center}

	\vfill

	{\large \begin{prooftree}
		\AxiomC{$e_1 \Downarrow \FIX .~e~/~t_1$}
		\AxiomC{$e_2 \Downarrow v_2~/~t_2$}
		\noLine
		\BinaryInfC{$[0\mapsto \FIX.~e,~1\mapsto v_2]e \Downarrow v~/~t_3$}
		\RightLabel{\normalsize\textsc{E-AppFix}}
		\UnaryInfC{$e_1~e_2 \Downarrow v~/~t_1,~t_2,~t_3$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$e_1 \Downarrow x~/~t_1$}
		\AxiomC{$e_2 \Downarrow n~/~t_2$}
		\RightLabel{\normalsize\textsc{E-AppExtVar}}
		\BinaryInfC{$e_1~e_2 \Downarrow m~/~t_1,~t_2~,~x(n)=m$}
	\end{prooftree}}
	入力は非決定的
\end{frame}

\begin{frame}
	\frametitle{代入を用いた理由}
	\LARGE 環境を用いても意味を定義できる
	\begin{center}
		凡例:$\varepsilon \vdash e \Downarrow v~/~t$
	\end{center}
	\vfill
	一方クロージャ同士の比較が面倒
	{\Large \[\texttt{Closure}(\varepsilon, e) \not = \texttt{Closure}((v, \varepsilon), \uparrow^1_1 e) \]}
	\vfill
	代入を用いた場合
	\[\lambda.~[1\mapsto v, \varepsilon]\uparrow^1_1 e = \lambda.~[1\mapsto\varepsilon]e\]
\end{frame}

\begin{frame}
	\frametitle{大ステップ意味論の問題点(1/2)}
	\begin{columns}
		\begin{column}{0.4\textwidth}
			{\LARGE エラー}
			{\large \[ \TRUE~\TRUE \not \Downarrow v~/~t \]}
			適用できる規則が無い
		\end{column}
		\begin{column}{0.6\textwidth}
			{\LARGE 無限ループ}
			{\large \[ (\FIX.~0~1)~\TRUE \not\Downarrow v~/~t \]}
			有限回の規則適用で導出できない
		\end{column}
	\end{columns}

	\vfill

	\begin{center}
		{\LARGE 区別できない}
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{大ステップ意味論の問題点(2/2)}
	\LARGE 同じ無限ループでも
	\vfill
	\begin{columns}
		\begin{column}{0.5\textwidth}
			{\LARGE 有限回の入出力}
			{\normalsize \[ (\FIX.~0~1)~(\texttt{print\_int}~\texttt{42}) \not \Downarrow v~/~t \]}
		\end{column}
		\begin{column}{0.5\textwidth}
			{\LARGE 無限回の入出力}
			{\normalsize \[ (\FIX.~0~(\texttt{print\_int}~\texttt{42}))~\texttt{0} \not\Downarrow v~/~t \]}
		\end{column}
	\end{columns}
	\vfill
	\begin{center}
		{\LARGE 区別できない}
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{余帰納的大ステップ意味論(1/3)}
	\LARGE
	余帰納的に定義 [Leroy, Grall 2009]
	{\Large \begin{center}
		凡例:$e \Uparrow /~t$
	\end{center}}

	\vfill

	{\large \begin{prooftree}
		\AxiomC{$e_1 \Downarrow \FIX.~e~/~t_1$}
		\AxiomC{$e_2 \Uparrow /~ t_2$}
		\RightLabel{\normalsize \textsc{D-AppR}}
		\doubleLine
		\BinaryInfC{$e_1~e_2 \Uparrow /~t_1~t_2$}
	\end{prooftree}}

	\vfill

	{\large \begin{prooftree}
		\AxiomC{$e_1 \Downarrow \FIX.~e~/~t_1$}
		\AxiomC{$e_2 \Downarrow v_2~/~t_2$}
		\noLine
		\BinaryInfC{$[0 \mapsto \FIX~e,~1\mapsto v_2]e \Uparrow / ~t_3$}
		\RightLabel{\normalsize \textsc{D-App}}
		\doubleLine
		\UnaryInfC{$e_1~e_2 \Uparrow/~t_1~t_2~t_3$}
	\end{prooftree}}
\end{frame}

\begin{frame}
	\frametitle{余帰納的大ステップ意味論(2/3)}
	\LARGE
	\begin{columns}
		\begin{column}{0.4\textwidth}
			エラー
			{\Large \[ \TRUE~\TRUE \not\Uparrow / ~t \]}
			{\normalsize 適用できる規則がない}
		\end{column}
		\begin{column}{0.6\textwidth}
			無限ループ
			{\Large \[ (\FIX.~0~1)~\TRUE \Uparrow / \]}
			{\normalsize 無限回の規則適用を許す}
		\end{column}
	\end{columns}

	\vfill

	\begin{center}
		区別できる
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{余帰納的大ステップ意味論(3/3)}
	\LARGE 停止しない式同士も区別可能

	\vfill

	\begin{columns}
		\begin{column}{0.5\textwidth}
			有限回の入出力
			{\normalsize \[\begin{array}{l}
				(\FIX.~0~1)~(\texttt{print\_int}~\texttt{42})\Uparrow / \\
				\texttt{print\_int}(42)=0
			\end{array}\]}
		\end{column}
		\begin{column}{0.5\textwidth}
			無限回の入出力
			{\normalsize \[\begin{array}{l}
				(\FIX.~0~(\texttt{print\_int}~\texttt{42}))~\texttt{0} \Uparrow / \\
				\texttt{print\_int}(42)=0, \\
				\texttt{print\_int}(42)=0, \cdots
			\end{array}\]}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{評価関係の導出例}
	\tiny
	\begin{prooftree}
		\AxiomC{$\vdots$}
		\AxiomC{$\vdots$}
		\AxiomC{$\vdots$}
		\doubleLine
		\UnaryInfC{$(\FIX.~0~(\texttt{p}~\texttt{42}))~(\texttt{p}~\texttt{42})~/~\texttt{p}(42)=0, \cdots$}

		\doubleLine
		\TrinaryInfC{$(\FIX.~0~(\texttt{p}~\texttt{42}))~(\texttt{p}~\texttt{42})~/~\texttt{p}(42)=0, \texttt{p}(42)=0, \cdots$}
	\end{prooftree}
\end{frame}

\begin{frame}
	\frametitle{関連研究:ラベル付き小ステップ意味論}
	\LARGE 
	{\Large \[\texttt{read\_int}~\texttt{0} + 34 \xrightarrow{\texttt{read\_int(0)}=12} 12 + 34 \longrightarrow 45 \]}

	\vfill

	$\tau$遷移の取り扱いが面倒
	\begin{itemize}
		\item 弱双模倣やup-to reductionが必要
	\end{itemize}
\end{frame}

\section{正当性の検証}

\begin{frame}
	\frametitle{K正規化前後の評価の対応(1/2)}
	{\LARGE K正規化後の項を評価}

	\vfill

	\Large 整数値または真偽値なら評価結果は一致
	\begin{itemize}
		\item 入出力は整数値に限定したため一致
	\end{itemize}
	{\normalsize \begin{columns}
		\begin{column}{0.4\textwidth}
			\[\begin{array}{l}
				\texttt{read\_int 0}\Downarrow 42 \\
				/~\texttt{read\_int}(\texttt{0})=42
			\end{array}\]
		\end{column}
		\begin{column}{0.4\textwidth}
			\[ 
				\begin{array}{l}
					\LET~\texttt{read\_int}~\IN \\
					\LET~0~\IN~1~0~\Downarrow 42 \\
					/~\texttt{read\_int}(\texttt{0})=42
				\end{array}
			\]
		\end{column}
	\end{columns}}

	\vfill

	関数抽象の中は評価されない
	{\normalsize \begin{columns}
		\begin{column}{0.4\textwidth}
			\[\begin{array}{l}
				\lambda.~\texttt{read\_int 0} \Downarrow \\
				\lambda.~\texttt{read\_int 0}~/
			\end{array} \]
		\end{column}
		\begin{column}{0.6\textwidth}
			\[ \begin{array}{l}
				\lambda.~\LET~\texttt{read\_int}~\IN \\
				\LET~0~\IN~1~0\Downarrow
				\lambda.~\LET~\texttt{read\_int}~\IN \\
				\LET~0~\IN~1~0~/ \\
			\end{array} \]
		\end{column}
	\end{columns}}
\end{frame}

\begin{frame}
	\frametitle{K正規化前後の評価の対応(2/2)}
	{\Large
	以上を定式化すると
	\begin{theorem}\label{theorem:evalto-correctness}
		$e\Downarrow v~/~t$ならば，$K(e)\Downarrow v'~/~t$かつ
		$v$が整数または真偽値ならば$v=v'$
	\end{theorem}
	\begin{theorem}
		$e\Uparrow/~T$ならば$K(e)\Uparrow/~t$
	\end{theorem}}
	定理2は余帰納法で証明できる
\end{frame}

\begin{frame}
	\frametitle{帰納法の仮定の強化}
	\LARGE 定理1を証明するには\\帰納法の仮定の強化が必要
	\vfill
	\begin{hypothesis}
		{\Large $e\Downarrow v~/~t$がならば$K(e)\Downarrow K(v)~/~t$}
	\end{hypothesis}
	一見成り立ちそうに見える
\end{frame}

\begin{frame}
	\frametitle{仮説1の問題点}
	\LARGE 複合的な値があるため成り立たない

	\vfill
	\renewcommand{\thehypothesis}{1}
	\begin{hypothesis}
		{\Large $e\Downarrow v~/~t$がならば$K(e)\Downarrow K(v)~/~t$}
	\end{hypothesis}
	\Large
	$v=(v_1,~v_2)$のとき
	\[K(v)=\LET~v_1~\IN~\LET~\uparrow^1 v_2~\IN~(1,0)\]
	従って$K(e)\not\Downarrow K(v)~/~t$
\end{frame}

\begin{frame}
	\frametitle{帰納法の仮定の強化 再試行(1/2)}
	\LARGE K正規化前後の値の対応関係を定義

	{\large \begin{prooftree}
		\AxiomC{$\forall i\in \{2,\cdots,n+1\}.~v_i \rhd v_i'$}
		\UnaryInfC{$\begin{array}{c}
			\FIX.~[2\mapsto v_2,~\cdots , n+1\mapsto v_{n+1}]e\\
			\rhd~\FIX.~[2\mapsto v_2',~\cdots , n+1\mapsto v_{n+1}']K(e) \\
		\end{array}$}
	\end{prooftree}

	\begin{prooftree}
		\AxiomC{$v_1 \rhd v_1'$}
		\AxiomC{$v_2 \rhd v_2'$}
		\BinaryInfC{$(v_1,~v_2) \rhd (v_1',~v_2')$}
	\end{prooftree}}
\end{frame}

\begin{frame}
	\frametitle{帰納法の仮定の強化 再試行(2/2)}
	\large
	\begin{lemma}
		$[0\mapsto v_0,\cdots , n-1\mapsto v_{n-1}]e\Downarrow v~/~t$かつ\\
		$\forall i\in \{0,\cdots,n-1\}.~v_i \rhd v_i'$がならば，
		\[[0\mapsto v_0',\cdots , n-1\mapsto v_{n-1}']K(e)\Downarrow v'~/~t\]及び
		$v\rhd v'$となる$v'$が存在
	\end{lemma}

	\begin{itemize}
		\item $[0\mapsto v_0,\cdots , n-1\mapsto v_{n-1}]e\Downarrow v~/~t$の\\
			導出についての帰納法で証明
		\item 関数適用や$\LET$の評価で代入が起こる
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{論理関係}
	\Large プログラム等価性に用いられる証明手法
	\begin{itemize}
		\item 型無しの言語に適用しづらい
		\item 再帰関数の扱いが面倒
			\begin{itemize}
				\item unwindingに関する補題が必要
			\end{itemize}
	\end{itemize}
\end{frame}

\section{結論}

\begin{frame}
	\frametitle{結論}
	\LARGE 入出力を含む高階関数型言語の\\
	K正規化をCoqで検証
	\begin{itemize}
		\item 無限に入出力が続く場合も検証
		\item de Bruijnインデックス，\\
			余帰納的大ステップ意味論の採用で証明を簡潔に
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{今後の課題}
	\LARGE n-aryの構文を追加
	\begin{itemize}
		\item 複数引数の関数呼び出し
		\item 相互再帰
		\item 組
	\end{itemize}
	{\large Coqでの取り扱いが面倒なため今回は省略}

	\vfill

	{\Large 例外や配列のように入出力以外の副作用}
\end{frame}

\end{document}
