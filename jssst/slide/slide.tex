\documentclass[dvipdfmx,cjk,xcolor=dvipsnames,envcountsect,notheorems,12pt]{beamer}
% * 16:9 のスライドを作るときは、aspectratio=169 を documentclass のオプションに追加する
% * 印刷用の配布資料を作るときは handout を documentclass のオプションに追加する
%   （overlay が全て一つのスライドに出力される）

\usepackage{pxjahyper}% しおりの文字化け対策 (なくても良い)
\usepackage{amsmath,amssymb,amsfonts,amsthm,ascmac,cases,bm,pifont}
\usepackage{graphicx}
\usepackage{bussproofs}
\usepackage{url}
\usepackage{etex}

% スライドのテーマ
\usetheme{sumiilab}
% ベースになる色を指定できる
%\usecolortheme[named=Magenta]{structure}
% 数式の文字が細くて見難い時は serif の代わりに bold にしましょう
%\mathversion{bold}

%% ===============================================
%% スライドの表紙および PDF に表示される情報
%% ===============================================

%% 発表会の名前とか（省略可）
\session{日本ソフトウェア科学会第33回大会}
%% スライドのタイトル
\title{\underline{無限の入出力}を行う\\ \underline{関数型プログラム}のK正規化の\\形式的検証}
%% 必要ならば、サブタイトルも
%\subtitle{}
%% 発表者のお名前
\author{水野雅之　住井英二郎}
%% 発表者の所属（[] 内は短い名前）
% \institute[東北大学　住井・松田研]{工学部　情報知能システム総合学科\\住井・松田研究室}% 学部生
\institute[東北大学　住井・松田研]{東北大学 大学院情報科学研究科}% 院生
%% 発表する日
\date{2016年9月9日}

%% ===============================================
%% 自動挿入される目次ページの設定（削除しても可）
%% ===============================================

%% section の先頭に自動挿入される目次ページ（削除すると、表示されなくなる）
\AtBeginSection[]{
\begin{frame}
  \frametitle{アウトライン}
  \tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/show/hide]
\end{frame}}
%% subsection の先頭に自動挿入される目次ページ（削除すると、表示されなくなる）
\AtBeginSubsection[]{
\begin{frame}
  \frametitle{アウトライン}
  \tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]
\end{frame}}

%% 現在の section 以外を非表示にする場合は以下のようにする

%% \AtBeginSection[]{
%% \begin{frame}
%%   \frametitle{アウトライン}
%%   \tableofcontents[sectionstyle=show/hide,subsectionstyle=show/show/hide]
%% \end{frame}}
%% \AtBeginSubsection[]{
%% \begin{frame}
%%   \frametitle{アウトライン}
%%   \tableofcontents[sectionstyle=show/hide,subsectionstyle=show/shaded/hide]
%% \end{frame}}

%% ===============================================
%% 定理環境の設定
%% ===============================================

\setbeamertemplate{theorems}[numbered]% 定理環境に番号を付ける
\theoremstyle{definition}
\newtheorem{definition}{定義}
\newtheorem{axiom}{公理}
\newtheorem{theorem}{定理}
\newtheorem{lemma}{補題}
\newtheorem{corollary}{系}
\newtheorem{proposition}{命題}

%% ===============================================
%% ソースコードの設定
%% ===============================================

\usepackage{listings,jlisting}
%\usepackage[scale=0.9]{DejaVuSansMono}

\definecolor{DarkGreen}{rgb}{0,0.5,0}
% プログラミング言語と表示するフォント等の設定
\lstset{
  language={[Objective]Caml},% プログラミング言語
  basicstyle={\ttfamily\small},% ソースコードのテキストのスタイル
  keywordstyle={\bfseries},% 予約語等のキーワードのスタイル
  commentstyle={},% コメントのスタイル
  stringstyle={},% 文字列のスタイル
  frame=trlb,% ソースコードの枠線の設定 (none だと非表示)
  numbers=none,% 行番号の表示 (left だと左に表示)
  numberstyle={},% 行番号のスタイル
  xleftmargin=5pt,% 左余白
  xrightmargin=5pt,% 右余白
  keepspaces=true,% 空白を表示する
  mathescape,% $ で囲った部分を数式として表示する ($ がソースコード中で使えなくなるので注意)
  % 手動強調表示の設定
  moredelim=[is][\itshape]{@/}{/@},
  moredelim=[is][\color{red}]{@r\{}{\}@},
  moredelim=[is][\color{blue}]{@b\{}{\}@},
  moredelim=[is][\color{DarkGreen}]{@g\{}{\}@},
}

\newcommand{\keyword}[1]{\mathbf{#1}}
\newcommand{\LET}{\keyword{let}}
\newcommand{\IF}{\keyword{if}}
\newcommand{\THEN}{\keyword{then}}
\newcommand{\ELSE}{\keyword{else}}
\newcommand{\FIX}{\keyword{fix}}
\newcommand{\CREATE}{\keyword{create}}
\newcommand{\AND}{\keyword{and}}
\newcommand{\IN}{\keyword{in}}
\newcommand{\TRUE}{\keyword{true}}
\newcommand{\WHILE}{\keyword{while}}
\newcommand{\DO}{\keyword{do}}
\newcommand{\DONE}{\keyword{done}}

%% ===============================================
%% 本文
%% ===============================================
\begin{document}
\frame[plain]{\titlepage}% タイトルページ

\section*{アウトライン}

% 目次を表示させる（section を表示し、subsection は隠す）
\begin{frame}
  \frametitle{アウトライン}
  \tableofcontents[sectionstyle=show,subsectionstyle=hide]
\end{frame}

\begin{frame}
	\frametitle{背景:コンパイラの形式的検証の意義}
	\begin{columns}
		\begin{column}{0.6\textwidth}
			\LARGE コンパイラのバグ
			\begin{itemize}
				\item 生成されるコードに影響
				\item デバッグが困難
			\end{itemize}

			\vfill

			\begin{center}
				$\downarrow$
			\end{center}

			\vfill

			形式的検証が有用
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{背景:既存研究(1/2)}
	\LARGE CompCert [Leroy+ 2006]
	\begin{itemize}
		\item Cコンパイラの正当性の検証
			\begin{itemize}
				\item 高階関数が無い
			\end{itemize}
	\end{itemize}

	Lambda Tamer [Chlipala 2010]
	\begin{itemize}
		\item 非純粋高階関数型言語処理系の正当性の検証
			\begin{itemize}
				\item 入出力はサポートしない
			\end{itemize}
	\end{itemize}

	\vfill

	入出力がある高階関数型言語は少ない
\end{frame}

\begin{frame}
	\frametitle{背景:関連研究(2/2)}
	\LARGE
	同様の研究
	入出力を含む高階関数型言語を対象

	\vfill

	Pilsner [Neis+ 2015]
	\begin{itemize}
		\item 名前で束縛を表現
		\item 小ステップ意味論
		\item 論理関係
	\end{itemize}

	CakeML [Tan+ 2016]
	\begin{itemize}
		\item ソース言語の束縛は名前で表現
		\item 中間言語の束縛はde Bruijnインデックスで表現
		\item クロックを用いた大ステップ意味論
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{研究の貢献}
	\LARGE 入出力を含む高階関数型言語における\\
	K正規化を検証
	\begin{itemize}
		\item 無限に入出力が続く場合も検証
			\begin{itemize}
				\item 余帰納的大ステップ意味論
			\end{itemize}
		\item 証明を簡潔に
			\begin{itemize}
				\item de Buijnインデックス
			\end{itemize}
	\end{itemize}
\end{frame}

\section{対象言語}

\begin{frame}
	\frametitle{対象言語}
	{\normalsize
	\[ \begin{array}{lcll}
		e & ::= & & \mbox{式} \\
				& & c	& \mbox{定数} \\
				& | & e_1 \odot e_2 & \mbox{算術演算} \\
				& | & \IF~e_1~\THEN~e_2~\ELSE~e_3 & \mbox{条件分岐} \\
				& | & \LET~x=e_1~\IN~e_2 & \mbox{変数定義} \\
				& | & x & \mbox{変数} \\
				& | & \FIX~f~x.~e & \mbox{再帰関数} \\
				& | & e_1~e_2 & \mbox{関数呼び出し} \\
				& | & (e_1,~e_2) & \mbox{二つ組の作成} \\
				& | & \pi_i~e & \mbox{射影}(i \in \{0, 1\}) \\
	\end{array} \]}
\end{frame}

\begin{frame}
	\frametitle{外部関数呼び出し}
	\LARGE \alert{自由変数}への関数呼び出し

	\vfill

	\begin{center}
		\Large
		$ \alert{\texttt{print\_int}}~42 $
	\end{center}

	\vfill

	外部関数呼び出しとみなす
	\begin{itemize}
		\item 整数を受け取って整数を返すものに限定
	\end{itemize}
\end{frame}

\section{K正規化}

\begin{frame}
	\frametitle{K正規化}
	\LARGE
	全ての部分式に名前を付ける

	\begin{columns}
		\begin{column}{0.5\textwidth}
			\begin{center}
				$a+b*c+d$
			\end{center}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{center}
				\[
					\begin{array}{l}
						\alert<2>{\LET~x =} b * c~\alert<2>{\IN} \\
						\alert<2>{\LET~y =} a + x~\alert<2>{\IN} \\
						y + d
					\end{array}
				\]
			\end{center}
		\end{column}
	\end{columns}

	\vfill

	\alert<2>{束縛に関する操作}
	\pause
\end{frame}

\section{束縛の表現}

\begin{frame}
	\frametitle{名前による表現の問題点}
	\LARGE $\alpha$等価性の議論が面倒
	\[ \lambda x.\lambda y.~x \simeq \lambda a.\lambda b.~a \]

	\vfill

	freshな名前が必要になる
	\begin{itemize}
		\item 束縛の関係を乱さないよう変数名を選ぶ
	\end{itemize}
	\[
		\begin{array}{lcl}
			[x \mapsto z](\lambda z.~x) & \simeq & \lambda z'.~z \\
																	& \not \simeq & \lambda z.~z
		\end{array}
	\]
\end{frame}

\begin{frame}
	\frametitle{de Bruijnインデックス}
	\LARGE
	何番目の束縛かで変数の出現を表現
	\begin{itemize}
		\item 内側から外側へ数える
	\end{itemize}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\[ \lambda x.~x~(\lambda y.~x~y) \]
		\end{column}
		\begin{column}{0.5\textwidth}
			\[ \lambda.~0~(\lambda.~1~0) \]
		\end{column}
	\end{columns}

	\vfill

	$\alpha$等価な式は構文的に等価
	\begin{itemize}
		\item 名前のfreshnessを保証
	\end{itemize}
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\[ \lambda x.\lambda y.~x \]
			\[ \lambda a.\lambda b.~a \]
		\end{column}
		\begin{column}{0.5\textwidth}
			\[ \lambda.\lambda.~1 \]
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{シフト}
	\LARGE 自由変数のインデックスをずらす
	\[\uparrow^d t \]

	束縛に関する操作

	\vfill

	{\large \begin{columns}
		\begin{column}{0.5\textwidth}
			\centering
			$\begin{array}{l}
				\lambda z.~(\lambda x.\lambda y.~x)~z \\
				\rightarrow \lambda z.\lambda y.~z
			\end{array}$
		\end{column}
		\begin{column}{0.5\textwidth}
			\centering
			$\begin{array}{l}
				\lambda.~(\lambda.\lambda.~1)~0\\
				\rightarrow \lambda.\lambda.~\only<2>{\alert{1}}\only<1>{\alert{\uparrow^1 0}}
			\end{array}$
		\end{column}
	\end{columns}}
	\pause
\end{frame}

\begin{frame}[fragile]
	\frametitle{K正規化の実装}
	\LARGE シフトを用いる

	\vfill

	{\large \[\begin{array}{l}
		K(\IF~e_1~\THEN~e_2~\ELSE~e_3) = \\
		\LET~a=\TRUE~\IN~\IF~a~\THEN~ K(e_1)~\ELSE~ K(e_2)
	\end{array}\]

	\vfill
	
	\[\begin{array}{l}
		K(\IF~e_1~\THEN~e_2~\ELSE~e_3) = \\
		\LET~\TRUE~\IN~\IF~0~\THEN~\uparrow^1 K(e_1)~\ELSE~\uparrow^1 K(e_2)
	\end{array}\]}
\end{frame}

\begin{frame}
	\frametitle{本研究での自由変数の表現}
	\LARGE
	自由変数は名前で表現

	\vfill

	{\Large \[(\FIX~f~x.~\texttt{print\_int}~x)~42\]

	\vfill

	\[\texttt{App}~(\texttt{Fix}~(\texttt{App}~(\texttt{ExtVar}~v)~(\texttt{Var}~1)))~(\texttt{Int}~42)\]}
	{\large \begin{center}
		($v$は$\texttt{print\_int}$を表す自然数)
	\end{center}}
\end{frame}

\begin{frame}
	\frametitle{局所名前無し表現}
	\LARGE 自由変数は名前で表現

	\vfill 

	シフトの代わりにopenとclose

	\only<1>{\begin{center}
		$\lambda.~(\lambda.\lambda.~1)~0 \rightarrow \lambda.\lambda.~1$
	\end{center}}
	\only<2>{\begin{prooftree}
		\AxiomC{$\alert{((\lambda.\lambda.~1)~0)^z} \rightarrow \alert{(\lambda.~1)^z}$}
		\RightLabel{{\large \textsc{E-Abs}}}
		\UnaryInfC{$\lambda.~(\lambda.\lambda.~1)~0 \rightarrow \lambda.\lambda.~1 $}
	\end{prooftree}}
	\only<3>{\begin{prooftree}
		\AxiomC{$\alert{(\lambda.\lambda.~1)~z} \rightarrow \alert{\lambda.~z}$}
		\RightLabel{{\large \textsc{E-Abs}}}
		\UnaryInfC{$\lambda.~(\lambda.\lambda.~1)~0 \rightarrow \lambda.\lambda.~1 $}
	\end{prooftree}}
	\only<4>{\begin{prooftree}
		\AxiomC{}
		\RightLabel{{\large \textsc{E-AppAbs}}}
		\UnaryInfC{$(\lambda.\lambda.~1)~z \rightarrow \alert{(\lambda.~1)^z} $}
		\RightLabel{{\large \textsc{E-Abs}}}
		\UnaryInfC{$\lambda.~(\lambda.\lambda.~1)~0 \rightarrow \lambda.\lambda.~1 $}
	\end{prooftree}}
\end{frame}

\begin{frame}
	\frametitle{局所名前無し表現の問題点}
	\LARGE well-formedである証明が必要
	\begin{itemize}
		\item locally closed
	\end{itemize}

	\vfill

	{\large \[\begin{array}{rcl}
		K(\FIX.~e) & \equiv & \FIX.~{}^{\backslash x}(K(e^x)) \\
		K(e_1~e_2) & \equiv & \LET~ K(e_1)~\IN~\LET~K(e_2)~\IN~1~0 \\
	\end{array}\]}
	帰納的定義に証明が必要
\end{frame}

\begin{frame}
	\frametitle{パラメトリック高階抽象構文(PHOAS)}
	\LARGE
	ホスト言語の束縛を流用
	\[\texttt{Abs}~(\texttt{fun}~x \Rightarrow \texttt{Var}~x)\]

	\begin{itemize}
		\item 名前の付け替えや代入をメタ言語に任せられる
		\item メタ言語の性質に関する証明が必要になる
	\end{itemize}
\end{frame}

\section{意味論の定義}

\begin{frame}
	\frametitle{本研究の意味論}
	\Large
	大ステップ意味論を入出力の列で拡張
	\[e \Downarrow v~/~t\]

	\vfill

	{\large \begin{prooftree}
		\AxiomC{$e_1 \Downarrow \FIX .~e~/~t_1$}
		\AxiomC{$e_2 \Downarrow v_2~/~t_2$}
		\noLine
		\BinaryInfC{$[0\mapsto \FIX.~e,~1\mapsto v_2]e \Downarrow v~/~t_3$}
		\RightLabel{\normalsize\textsc{E-AppFix}}
		\UnaryInfC{$e_1~e_2 \Downarrow v~/~t_1~t_2~t_3$}
	\end{prooftree}
	\begin{prooftree}
		\AxiomC{$e_1 \Downarrow x~/~t_1$}
		\AxiomC{$e_2 \Downarrow n~/~t_2$}
		\RightLabel{\normalsize\textsc{E-AppExtVar}}
		\BinaryInfC{$e_1~e_2 \Downarrow m~/~t_1~t_2~,~x(n)=m$}
	\end{prooftree}}

	\vfill

	環境の代わりに代入を用いる
\end{frame}

\begin{frame}
	\frametitle{大ステップ意味論の問題点}
	\begin{columns}
		\begin{column}{0.4\textwidth}
			{\LARGE エラー}
			{\large \[ \neg (\TRUE~\TRUE \Downarrow v~/~t) \]}
			適用できる規則が無い
		\end{column}
		\begin{column}{0.6\textwidth}
			{\LARGE 無限ループ}
			{\large \[ \neg ((\FIX.~0~1)~\TRUE \Downarrow v~/~t) \]}
			有限回の規則適用で導出できない
		\end{column}
	\end{columns}

	\vfill

	\begin{center}
		{\LARGE 区別できない}
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{余帰納的大ステップ意味論(1/3)}
	\LARGE
	余帰納的に定義 [Leroy, Grall 2009]
	{\Large \[e \Uparrow /~t\]}

	\vfill

	{\large \begin{prooftree}
		\AxiomC{$e_1 \Downarrow \FIX.~e~/~t_1$}
		\AxiomC{$e_2 \Uparrow /~ t_2$}
		\RightLabel{\normalsize \textsc{D-AppR}}
		\doubleLine
		\BinaryInfC{$e_1~e_2 \Uparrow /~t_1~t_2$}
	\end{prooftree}}

	\vfill

	{\large \begin{prooftree}
		\AxiomC{$e_1 \Downarrow \FIX.~e~/~t_1$}
		\AxiomC{$e_2 \Downarrow v_2~/~t_2$}
		\noLine
		\BinaryInfC{$[0 \mapsto \FIX~e,~1\mapsto v_2]e \Uparrow / ~t_3$}
		\RightLabel{\normalsize \textsc{D-App}}
		\doubleLine
		\UnaryInfC{$e_1~e_2 \Uparrow/~t_1~t_2~t_3$}
	\end{prooftree}}
\end{frame}

\begin{frame}
	\frametitle{余帰納的大ステップ意味論(2/3)}
	\LARGE
	\begin{columns}
		\begin{column}{0.4\textwidth}
			エラー
			{\Large \[ \neg (\TRUE~\TRUE \Uparrow / ~t) \]}
			{\normalsize 適用できる規則がない}
		\end{column}
		\begin{column}{0.6\textwidth}
			無限ループ
			{\Large \[ (\FIX.~0~1)~\TRUE \Uparrow / \]}
			{\normalsize 無限回の規則適用を許す}
		\end{column}
	\end{columns}

	\vfill

	\begin{center}
		区別できる
	\end{center}
\end{frame}

\begin{frame}
	\frametitle{余帰納的大ステップ意味論(3/3)}
	\LARGE 停止しない式同士も区別可能

	\vfill

	\begin{columns}
		\begin{column}{0.5\textwidth}
			有限回の入出力
			{\normalsize \[\begin{array}{l}
				(\FIX.~0~1)~(\texttt{print\_int}~\texttt{42})\Uparrow / \\
				\texttt{print\_int}(42)=0
			\end{array}\]}
		\end{column}
		\begin{column}{0.5\textwidth}
			無限回の入出力
			{\normalsize \[\begin{array}{l}
				(\FIX.~0~(\texttt{print\_int}~\texttt{42}))~\texttt{0} \Uparrow / \\
				\texttt{print\_int}(42)=0, \\
				\texttt{print\_int}(42)=0, \cdots
			\end{array}\]}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{小ステップ意味論の問題点}
	\LARGE 
	{\normalsize \[\texttt{print\_int}~\texttt{42} + 1 \xrightarrow{\texttt{print\_int(42)}=0} 0 + 1 \longrightarrow 1 \]}

	\vfill

	入出力を伴うかの区別が面倒
	\begin{itemize}
		\item 弱双模倣
		\item up-to reduction
	\end{itemize}
\end{frame}

\section{正当性の検証}

\begin{frame}
	\frametitle{期待される性質(1/2)}
	{\LARGE K正規化後の項を評価}

	\vfill

	\Large 整数値または真偽値なら一致
	{\normalsize \begin{columns}
		\begin{column}{0.4\textwidth}
			\[\begin{array}{l}
				\texttt{print\_int 42}\Downarrow 0 \\
				/~\texttt{print\_int}(\texttt{42})=0
			\end{array}\]
		\end{column}
		\begin{column}{0.4\textwidth}
			\[ 
				\begin{array}{l}
					\LET~\texttt{print\_int}~\IN \\
					\LET~42~\IN \\
					1 + 0\Downarrow 0 \\
					/~\texttt{print\_int}(\texttt{42})=0
				\end{array}
			\]
		\end{column}
	\end{columns}}

	\vfill

	関数抽象の中は評価されない
	{\normalsize \begin{columns}
		\begin{column}{0.4\textwidth}
			\[ \begin{array}{l}
				\lambda.\lambda.\lambda.~2+1+0\\
				\Downarrow \lambda.\lambda.\lambda.~2+1+0~/
			\end{array} \]
		\end{column}
		\begin{column}{0.6\textwidth}
			\[ \begin{array}{l}
				\lambda.\lambda.\lambda.~\LET~2+1~\IN~0 + 1 \\
				\Downarrow \lambda.\lambda.\lambda.~\LET~2+1~\IN~0 + 1 ~/
			\end{array} \]
		\end{column}
	\end{columns}}
\end{frame}

\begin{frame}
	\frametitle{期待される性質(2/2)}
	{\Large
	\begin{theorem}\label{theorem:evalto-correctness}
		$e\Downarrow v~/~t$が成り立つならば$K(e)\Downarrow v'~/~t$が成り立ち，
		$v$が整数または真偽値ならば$v=v'$となる
	\end{theorem}
	\begin{theorem}
		$e\Uparrow/~T$が成り立つならば$K(e)\Uparrow/~t$が成り立つ
	\end{theorem}}
\end{frame}

\begin{frame}
	\frametitle{帰納法の仮定の強化 初試行(1/2)}
	\LARGE 帰納法の仮定を強化する必要がある
	\vfill
	\begin{proposition}
		{\Large $e\Downarrow v~/~t$が成り立つならば$K(e)\Downarrow K(v)~/~t$が成り立つ}
	\end{proposition}
	一見成り立ちそうに見える
\end{frame}

\begin{frame}
	\frametitle{帰納法の仮定の強化 初試行(2/2)}
	\LARGE 複合的な値があるため成り立たない

	\vfill
	\Large
	$v=(v_1,~v_2)$のとき
	\[K(v)=\LET~v_1~\IN~\LET~\uparrow^1 v_2~\IN~(1,0)\]
	従って$\neg (K(e)\Downarrow K(v)~/~t)$
\end{frame}

\begin{frame}
	\frametitle{帰納法の仮定の強化 再試行(1/2)}
	\LARGE K正規化前後の値の対応関係を定義

	{\large \begin{prooftree}
		\AxiomC{$\forall i\in \{2,\cdots,n+1\}.~v_i \rhd v_i'$}
		\UnaryInfC{$\begin{array}{c}
			\FIX.~[2\mapsto v_2,~\cdots , n+1\mapsto v_{n+1}]e\\
			\rhd~\FIX.~[2\mapsto v_2',~\cdots , n+1\mapsto v_{n+1}']K(e) \\
		\end{array}$}
	\end{prooftree}

	\begin{prooftree}
		\AxiomC{$v_1 \rhd v_1'$}
		\AxiomC{$v_2 \rhd v_2'$}
		\BinaryInfC{$(v_1,~v_2) \rhd (v_1',~v_2')$}
	\end{prooftree}}
\end{frame}

\begin{frame}
	\frametitle{帰納法の仮定の強化 再試行(2/2)}
	\large
	\begin{lemma}
		$[0\mapsto v_0,\cdots , n-1\mapsto v_{n-1}]e\Downarrow v~/~t$かつ\\
		$\forall i\in \{0,\cdots,n-1\}.~v_i \rhd v_i'$が成り立つならば，
		\[[0\mapsto v_0',\cdots , n-1\mapsto v_{n-1}']K(e)\Downarrow v'~/~t\]及び
		$v\rhd v'$が成り立つような$v'$が存在する
	\end{lemma}

	\begin{itemize}
		\item 評価関係の導出についての帰納法
		\item 代入が伴う評価規則に対応
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{論理関係}
	\Large プログラム等価性に用いられる証明手法
	\begin{itemize}
		\item 型無しの言語に適用しづらい
		\item 再帰関数の扱いが面倒
			\begin{itemize}
				\item unwinding
			\end{itemize}
	\end{itemize}
\end{frame}

\section{結論}

\begin{frame}
	\frametitle{結論}
	\LARGE 入出力を含む高階関数型言語における\\
	K正規化をCoqで検証できた
	\begin{itemize}
		\item 無限に入出力が続く場合も検証
		\item de Bruijnインデックス，\\
			余帰納的大ステップ意味論の採用で証明を簡潔に
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{今後の課題}
	\LARGE 可変個引数の構文を追加
	\begin{itemize}
		\item 複数引数の関数呼び出し
		\item 相互再帰
		\item 組
	\end{itemize}

	\vfill

	例外を取り扱えるように
	\begin{itemize}
		\item 除算
		\item 配列のアクセス
	\end{itemize}
\end{frame}

\end{document}
